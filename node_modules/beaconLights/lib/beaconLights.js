var PiStop = require('pistop');

var Beacon = function(uri, immediatePin, nearPin, farPin) {
    this.uri = uri;
    this.txPower = 0;
    this.rssiValues = [];
    this.lights = new PiStop(immediatePin, nearPin, farPin) ;
    this.timer = null;
    this.startTimer();
};

Beacon.prototype.startTimer = function() {
    var that = this;
    this.timer = setTimeout(function() {
        that.lights.clear();
    }, 5000);
};

Beacon.prototype.resetTimer = function() {
    clearTimeout(this.timer);
    this.startTimer();
};

Beacon.prototype.discovered = function(rssi, txPower, IMMEDIATE_RANGE, NEAR_RANGE, ROLLING_AVERAGE_SIZE) {
    this.rssiValues.push(rssi);
    this.rssiValues = trimStoredReadings(this.rssiValues, ROLLING_AVERAGE_SIZE);
    var calcValue =  calcAverage(this.rssiValues);
    //var range = calcRange(calcValue, txPower);
    var rangeAlt = calcRangeAlt(calcValue, txPower);
    if (rangeAlt < IMMEDIATE_RANGE) {
        this.lights.red();
    } else if ( rangeAlt > NEAR_RANGE ) {
        this.lights.green();
    } else if ( rangeAlt <= NEAR_RANGE && rangeAlt >= IMMEDIATE_RANGE ) {
        this.lights.amber();
    }
    this.resetTimer();
};

function calcRange(rssi, txPower) {
    var signalLoss = txPower - rssi;
    var rawRange = Math.sqrt(Math.pow(10, signalLoss / 10));
    //console.log('range = ' + rawRange)
    return Math.round(rawRange);
}

function calcRangeAlt(rssi, txPower) {
    //Alternative calculation to test, likely very similar answer!
    //rssi1m needs to be found with testing
    //Based on; http://matts-soup.blogspot.co.uk/2013/12/finding-distance-from-rssi.html

    // Using zero for rssi1m as currently beacons are broadcasting value a 1m via txPower
    var rssi1m = -68; // tested
    var pathLoss = 2; // free space 
    if (rssi > 0) { rssi = 0 };
    //var rawRange = Math.pow(10, (rssi - (txPower + rssi1m)) / (-10*pathLoss));
    var rawRange = Math.pow(10, (rssi - rssi1m) / (-10*pathLoss));
    console.log('range = ' + rawRange)
    return Math.round(rawRange);
}

function calcAverage(rssiValues) {
    var result = 0;
    for (var i = 0; i < rssiValues.length; i++) {
        result += rssiValues[i];
    }
    return result / rssiValues.length;
}

function trimStoredReadings(readings, trimToLength) {
    if ( readings.length > trimToLength ) {
        readings = readings.slice(-trimToLength);
    }
    return readings;
}


module.exports = Beacon;
